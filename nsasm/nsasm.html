<html>

  <head>
    <title>
      NSASM - Sparse Navier-Stokes Jacobian Assembly
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      NSASM <br> Sparse Navier-Stokes Jacobian Assembly
    </h1>

    <hr>

    <p>
      <b>NSASM</b>
      is a C library which
      carries out the
      finite element assembly of the jacobian matrix used in a Newton
      iteration to solve the steady state incompressible Navier Stokes
      equations in a 2D region, by Per-Olof Persson.
    </p>

    <p>
      The finite element approximation uses the P2-P1 triangular
      element, also known as the Taylor-Hood element.  The velocities
      are approximated quadratically, and the pressures linearly.
    </p>

    <p>
      The sparse matrix format used is known as the compressed
      column format, in which the nonzero entries and their row indices
      are stored in order by columns.
    </p>

    <p>
      The software assumes that a suitable mesh has been set up for the
      region, with arrays P and T defining that mesh, that an array
      defining the boundary constraints has been set up, and that an
      initial estimate of the flow has been made available.
    </p>

    <h3 align = "center">
      Invoking the Library
    </h3>

    <p>
      The software is designed to be compiled via MATLAB's mex facility.
      This means you have to have access to the MATLAB compiler mex;
      you also have to have a compiler on your computer; and you have to
      have (just once) set up your mex option by starting MATLAB and issuing
      the command "mbuild -setup".
    </p>

    <p>
      Then you need to make a compiled copy of the nsasm code.  You do this
      with the MATLAB command
      <pre>
        mex -largeArrayDims nsasm.c
      </pre>
      which, on my computer, results in the creation of the compiled file
      "nsasm.mexmaci64", although the name used on your system may differ.
      In any case, once this file has been created, MATLAB can invoke it
      as though it were a MATLAB M-file, with input and output arguments.
    </p>

    <p>
      The C code in NSASM sets up a linear system which is intended to be solved 
      by MATLAB.  Thus, the Newton iteration could have the following form 
      in a MATLAB program:
      <pre>
        for ii = 1 : 8
          [ K, L ] = nsasm ( p, t, np0, e, u, mu );
          du = - lusolve ( K, L );
          u = u + du;
          disp ( sprintf ( '%20.10g  %20.10g', norm ( L, inf ), norm ( du, inf ) ) );
        end
      </pre>
    </p>

    <h3 align = "center">
      Indexing Conventions
    </h3>

    <p>
      The software makes some particular assumptions about the
      numbering of nodes, variables, and local element nodes
    </p>

    <p>
      <i>(Indexing of nodes)</i> It is assumed that the mesh was
      generated by starting with a set of nodes, triangulating them,
      and then computing the midsides of the triangles and adding
      these midsides to the list of nodes.  In particular, the program
      therefore assumes that the numbering of the nodes reflects this
      process, so that all vertex nodes are numbered first, followed
      by the midside nodes.
    </p>

    <p>
      <i>(Indexing of global variables)</i> It is assumed that
      every node has an associated horizontal velocity variable "U",
      that every node has an associated vertical velocity variable "V",
      and that only vertex nodes or "pressure nodes" have an
      associated pressure variable "P".  The variables are stored in a
      single vector, first all the U's, then all the V's, then the
      P's.  Thus variable 1 is the value of U at node 1, variable
      NP+1 is the value of V at node 1, and variable 2*NP+1 is
      the value of P at node 1.
    </p>

    <p>
      Notice that there are even more global variables than you
      might think, since the boundary conditions and other constraints
      are handled by adding a Lagrange multiplier for each one.
      Thus the number of variables is actually 2*NP+NP0+NE.
    </p>

    <p>
      <i>(Numerical codes for U,V,P)</i>  In the E vector used to define
      constraints, the numeric codes 0, 1 and 2 are used for U, V and
      P variables respectively.
    </p>

    <p>
      <i>(Local numbering of nodes)</i>  When listing the 6 nodes
      that make up a triangle, the ordering should be as follows:
      <pre>
        N3
         |\
         | \
         |  \
        N5   N4
         |    \
         |     \
         |      \
        N1--N6--N2
      </pre>
    </p>

    <h3 align = "center">
      Usage:
    </h3>

    <p>
      <blockquote>
        [ <i>K</i>, <i>L</i> ] = <b>nsasm</b> ( <i>p</i>, <i>t</i>, <i>np0</i>,
        <i>e</i>, <i>u</i>, <i>nu</i> );
      </blockquote>
      where
      <ul>
        <li>
          <b>real P[2,NP]</b>, the coordinates of the nodes;
        </li>
        <li>
          <b>integer T[6,NT]</b>, the indices of the nodes that make up the elements; the node
          indices are 1-based, not 0-based;  the ordering of the 6 entries
          is vertex 1, vertex 2, vertex 3, then the node between vertex 2
          and vertex 3, then the node between vertex 3 and vertex 1, and
          then the node between vertex 1 and vertex 2. (This is a somewhat
          peculiar ordering.)
        </li>
        <li>
          <b>integer NP0</b>, the number of pressure nodes, that is, nodes which are <i>not</i>
          the vertices of a triangular element.
        </li>
        <li>
          <b>real E[3,NE]</b>, the constraints.  Each constraint is defined by listing a
          node index, a variable type (0=horizonal velocity, 1 = vertical
          velocity, 2 = pressure), and a value to be assigned that
          variable.
        </li>
        <li>
          <b>real U[2*NP+NP0+NE]</b>, the current estimate of the solution.
        </li>
        <li>
          <b>real NU</b>, the kinematic viscosity.
        </li>
        <li>
          <b>sparse K[]</b>, a sparse matrix containing the Jacobian matrix for the
          Newton iteration.
        </li>
        <li>
          <b>real L[2*NP+NP0+NE]</b>, the residual vector.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>NSASM</b> is available in
      <a href = "../../c_src/nsasm/nsasm.html"> a C version</a> and
      <a href = "../../f_src/nsasm/nsasm.html"> a FORTRAN90 version</a>,
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../../m_src/matlab_calls_c/matlab_calls_c.html">
      MATLAB_CALLS_C</a>,
      MATLAB programs which
      illustrate how C functions can be written, compiled, and
      called from MATLAB using the <b>mex</b> facility;
    </p>

    <p>
      <a href = "../../m_src/matlab_calls_f77/matlab_calls_f77.html">
      MATLAB_CALLS_F77</a>,
      MATLAB programs which
      illustrate how FORTRAN77 functions can be written, compiled, and
      called from MATLAB using MATLAB's <b>mex</b> facility;
    </p>

    <p>
      <a href = "../../m_src/mex/mex.html">
      MEX</a>,
      MATLAB programs which
      call lower-level functions written in traditional languages such
      as C, C++, FORTRAN77 or FORTRAN90, compiled with MATLAB's
      <b>mex</b> compiler.
    </p>

    <p>
      <a href = "../../c_src/super_lu/super_lu.html">
      SUPER_LU</a>,
      a C library which
      applies a fast direct solution method to a sparse linear system,
      by James Demmel, John Gilbert, and Xiaoye Li.
    </p>

    <h3 align = "center">
      Author:
    </h3>

    <p>
      Original C+MATLAB version by Per-Olof Persson.<br>
      This C+MATLAB version by John Burkardt.
    </p>

    <h3 align = "center">
      Reference:
    </h3>

    <p>
      <ol>
        <li>
          Klaus-Juergen Bathe,<br>
          Finite Element Procedures,<br>
          Prentice Hall, 1996.
        </li>
        <li>
          James Demmel, John Gilbert, Xiaoye Li,<br>
          SuperLU User's Guide,<br>
          September, 1999.
        </li>
        <li>
          Per-Olof Persson,<br>
          Implementation of Finite Element-Based Navier-Stokes Solver,<br>
          April 2002.
        </li>
        <li>
          Michael Schaefer, Stefan Turek,<br>
          Benchmark Computations of Laminar Flow Around a Cylinder,<br>
          Notes on Numerical Fluid Mechanics,<br>
          Volume 52, 1996, pages 547-566.
        </li>
      </ol>
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      The <b>C source code</b> carries out the assembly of the finite element matrix
      and residual.  To use it, you must compile it once.  To do that, you need 
      to set up mex (once), run matlab, and issue the "mex nsasm.c".  Since the
      file is C code, you can also compile it with any standard C compiler, but
      you will need to access the MEX include files invoked in the file.  The
      location of these include files depends on how your copy of MATLAB was installed.
      <ul>
        <li>
          <a href = "nsasm.c">nsasm.c</a>,
          the source code.
        </li>
        <li>
          <a href = "nsasm.sh">nsasm.sh</a>,
          commands to compile the source code as a simple C file, NOT
          using Matlab's MEX compiler.  This is simply to check for
          syntax errors, and to do this requires that you also access the
          MATLAB include files required by MEX.
        </li>
      </ul>
    </p>

    <p>
      The <b>MATLAB source code</b> comprises just a couple of utility routines
      to be called by the MATLAB test programs.
      <ul>
        <li>
          <a href = "nsasm_interface.m">nsasm_interface.m</a>,
          reads node, element and constraint data from files whose names
          are specified by the user, and calls the nsasm function to
          compute the stiffness matrix K and residual L.
        </li>
        <li>
          <a href = "r8sp_print_some.m">r8sp_print_some.m</a>,
          prints part of a sparse triplet matrix.
        </li>
        <li>
          <a href = "timestamp.m">timestamp.m</a>,
          prints the current YMDHMS date as
          a timestamp.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      The <b>SMALL</b> test defines a small sparse matrix,
      with 25 nodes, 8 elements, 33 constraints, NP0 = 9,
      NU = 100.0.
      <ul>
        <li>
          <a href = "small_test.m">small_test.m</a>,
          calls NSASM_INTERFACE for the "small" data.
        </li>
        <li>
          <a href = "small_test_output.txt">small_test_output.txt</a>,
          the printed output.
        </li>
        <li>
          <a href = "small_constraints.txt">small_constraints.txt</a>,
          the constraint file (3*33 entries), sets to zero the horizontal
          and vertical velocities at the 16 boundary nodes, and sets 1 pressure to 0.
        </li>
        <li>
          <a href = "small_nodes.txt">small_nodes.txt</a>,
          the point coordinate file, 25 nodes.
        </li>
        <li>
          <a href = "small_nodes.png">small_nodes.png</a>,
          a PNG image of the nodes.
        </li>
        <li>
          <a href = "small_elements.txt">small_elements.txt</a>,
          the element file, 8 quadratic (6 node) triangles.
        </li>
        <li>
          <a href = "small_elements.png">small_elements.png</a>,
          a PNG image of the elements.
        </li>
      </ul>
    </p>

    <p>
      The <b>BIG_CONSTRAINT_FILE_MAKER</b> program was set up because
      I lost or never had a copy of the "big_constraints.txt" file, and
      I had to guess the problem type (driven cavity) and the location
      of the boundary nodes on left, bottom and right, and then manufacture
      the appropriate constraint data:
      <ul>
        <li>
          <a href = "big_constraint_file_maker.m">big_constraint_file_maker.m</a>,
          reads "big_nodes.txt" and creates "big_constraints.txt".
        </li>
        <li>
          <a href = "big_constraint_file_maker_output.txt">big_constraint_file_maker_output.txt</a>,
          the printed output.
        </li>
      </ul>
    </p>

    <p>
      The <b>BIG</b> test defines a relatively large sparse matrix,
      with 2049 nodes, 960 elements, 387 constraints, NP0 = 545,
      NU = 500.0, a version of the driven cavity problem, with an
      unstructured mesh.
      <ul>
        <li>
          <a href = "big_test.m">big_test.m</a>,
          calls NSASM_INTERFACE for the "big" data.
        </li>
        <li>
          <a href = "big_test_output.txt">big_test_output.txt</a>,
          the printed output.
        </li>
        <li>
          <a href = "big_constraints.txt">big_constraints.txt</a>,
          the constraint file (3*1287 entries).
        </li>
        <li>
          <a href = "big_nodes.txt">big_nodes.txt</a>,
          the point coordinate file, 2049 nodes.
        </li>
        <li>
          <a href = "big_nodes.png">big_nodes.png</a>,
          a PNG image of the nodes.
        </li>
        <li>
          <a href = "big_elements.txt">big_elements.txt</a>,
          the element file, 960 quadratic (6 node) triangles.
        </li>
        <li>
          <a href = "big_elements.png">big_elements.png</a>,
          a PNG image of the elements.
        </li>
      </ul>
    </p>

   <p>
      The element data for the big problem is quadratic, and the assumption
      is made that the midside nodes are the midpoints of the corresponding
      vertices.  That is, the 6-noded triangles have straight sides, with the
      mid-side nodes actually at the geometric middles of their sides.  The easiest
      way to guarantee such a triangulation is to generate a triangulation with
      3-noded triangles, and then generate the midside nodes in the obvious way.
      Here we include the original 3-noded triangulation information.
      <ul>
        <li>
          <a href = "big_linear_nodes.txt">big_linear_nodes.txt</a>,
          the nodes for the linear triangulation.
        </li>
        <li>
          <a href = "big_linear_elements.txt">big_linear_elements.txt</a>,
          the elements for the linear triangulation.
        </li>
        <li>
          <a href = "big_linear_elements.png">big_linear_elements.png</a>,
          the elements for the linear triangulation.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      List of Routines:
    </h3>

    <p>
      The C file nsasm.c contains the following functions:
      <ul>
        <li>
          <b>mexFunction</b> is the interface between MATLAB and the C code.
        </li>
        <li>
          <b>ASSEMBLE</b> assembles the local stiffness and residual into global arrays.
        </li>
        <li>
          <b>ASSEMBLE_CONSTR</b> assembles the constraints.
        </li>
        <li>
          <b>INIT_SHAPE</b> evaluates the shape functions at the quadrature points.
        </li>
        <li>
          <b>IVEC_HEAP_D</b> reorders an array of integers into a descending heap.
        </li>
        <li>
          <b>IVEC_SORT_HEAP_A</b> ascending sorts an array of integers using heap sort.
        </li>
        <li>
          <b>LOCALKL</b> assembles the local stiffness matrix and residual.
        </li>
        <li>
          <b>SPARSE_CREATE</b> creates a sparse matrix.
        </li>
        <li>
          <b>SPARSE_SET</b> increments an entry of the sparse matrix.
        </li>
      </ul>
    </p>

    <p>
      You can go up one level to <a href = "../c_src.html">
      the C source codes</a>.
    </p>

    <hr>

    <i>
      Last revised on 07 April 2012.
    </i>

    <!-- John Burkardt -->

  </body>

</html>
